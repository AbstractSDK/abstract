{
  "contract_name": "memory",
  "contract_version": "0.1.0-rc.2",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "Memory Instantiate msg",
    "type": "object",
    "additionalProperties": false
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "Memory Execute msg",
    "oneOf": [
      {
        "description": "Updates the contract addressbook",
        "type": "object",
        "required": [
          "update_contract_addresses"
        ],
        "properties": {
          "update_contract_addresses": {
            "type": "object",
            "required": [
              "to_add",
              "to_remove"
            ],
            "properties": {
              "to_add": {
                "description": "Contracts to update or add",
                "type": "array",
                "items": {
                  "type": "array",
                  "items": [
                    {
                      "$ref": "#/definitions/UncheckedContractEntry"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              },
              "to_remove": {
                "description": "Contracts to remove",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/UncheckedContractEntry"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the Asset addressbook",
        "type": "object",
        "required": [
          "update_asset_addresses"
        ],
        "properties": {
          "update_asset_addresses": {
            "type": "object",
            "required": [
              "to_add",
              "to_remove"
            ],
            "properties": {
              "to_add": {
                "description": "Assets to update or add",
                "type": "array",
                "items": {
                  "type": "array",
                  "items": [
                    {
                      "type": "string"
                    },
                    {
                      "$ref": "#/definitions/AssetInfoBase_for_String"
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              },
              "to_remove": {
                "description": "Assets to remove",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sets a new Admin",
        "type": "object",
        "required": [
          "set_admin"
        ],
        "properties": {
          "set_admin": {
            "type": "object",
            "required": [
              "admin"
            ],
            "properties": {
              "admin": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AssetInfoBase_for_String": {
        "description": "Represents the type of an fungible asset\n\nEach **asset info** instance can be one of three variants:\n\n- Native SDK coins. To create an **asset info** instance of this type, provide the denomination. - CW20 tokens. To create an **asset info** instance of this type, provide the contract address. - CW1155 tokens. To create an **asset info** instance of this type, provide the contract address and token ID.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "native"
            ],
            "properties": {
              "native": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "cw20"
            ],
            "properties": {
              "cw20": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "cw1155"
            ],
            "properties": {
              "cw1155": {
                "type": "array",
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "UncheckedContractEntry": {
        "description": "Key to get the Address of a contract",
        "type": "object",
        "required": [
          "contract",
          "protocol"
        ],
        "properties": {
          "contract": {
            "type": "string"
          },
          "protocol": {
            "type": "string"
          }
        }
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "Memory smart-query",
    "oneOf": [
      {
        "description": "Queries assets based on name returns [`AssetsResponse`]",
        "type": "object",
        "required": [
          "assets"
        ],
        "properties": {
          "assets": {
            "type": "object",
            "required": [
              "names"
            ],
            "properties": {
              "names": {
                "description": "Names of assets to query",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Queries contracts based on name returns [`ContractsResponse`]",
        "type": "object",
        "required": [
          "contracts"
        ],
        "properties": {
          "contracts": {
            "type": "object",
            "required": [
              "names"
            ],
            "properties": {
              "names": {
                "description": "Project and contract names of contracts to query",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ContractEntry"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Page over contracts returns [`ContractListResponse`]",
        "type": "object",
        "required": [
          "contract_list"
        ],
        "properties": {
          "contract_list": {
            "type": "object",
            "properties": {
              "page_size": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "page_token": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/ContractEntry"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Page over assets returns [`AssetListResponse`]",
        "type": "object",
        "required": [
          "asset_list"
        ],
        "properties": {
          "asset_list": {
            "type": "object",
            "properties": {
              "page_size": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint8",
                "minimum": 0.0
              },
              "page_token": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ContractEntry": {
        "description": "Key to get the Address of a contract Use [`UncheckedContractEntry`] to construct this type.",
        "type": "object",
        "required": [
          "contract",
          "protocol"
        ],
        "properties": {
          "contract": {
            "type": "string"
          },
          "protocol": {
            "type": "string"
          }
        }
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "type": "object",
    "additionalProperties": false
  },
  "sudo": null,
  "responses": {
    "asset_list": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AssetListResponse",
      "description": "Query response",
      "type": "object",
      "required": [
        "assets"
      ],
      "properties": {
        "assets": {
          "description": "Assets (name, assetinfo)",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "$ref": "#/definitions/AssetEntry"
              },
              {
                "$ref": "#/definitions/AssetInfoBase_for_Addr"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetEntry": {
          "description": "May key to retrieve information on an asset",
          "type": "string"
        },
        "AssetInfoBase_for_Addr": {
          "description": "Represents the type of an fungible asset\n\nEach **asset info** instance can be one of three variants:\n\n- Native SDK coins. To create an **asset info** instance of this type, provide the denomination. - CW20 tokens. To create an **asset info** instance of this type, provide the contract address. - CW1155 tokens. To create an **asset info** instance of this type, provide the contract address and token ID.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "native"
              ],
              "properties": {
                "native": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "cw20"
              ],
              "properties": {
                "cw20": {
                  "$ref": "#/definitions/Addr"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "cw1155"
              ],
              "properties": {
                "cw1155": {
                  "type": "array",
                  "items": [
                    {
                      "$ref": "#/definitions/Addr"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "assets": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AssetsResponse",
      "description": "Query response",
      "type": "object",
      "required": [
        "assets"
      ],
      "properties": {
        "assets": {
          "description": "Assets (name, assetinfo)",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "$ref": "#/definitions/AssetEntry"
              },
              {
                "$ref": "#/definitions/AssetInfoBase_for_Addr"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetEntry": {
          "description": "May key to retrieve information on an asset",
          "type": "string"
        },
        "AssetInfoBase_for_Addr": {
          "description": "Represents the type of an fungible asset\n\nEach **asset info** instance can be one of three variants:\n\n- Native SDK coins. To create an **asset info** instance of this type, provide the denomination. - CW20 tokens. To create an **asset info** instance of this type, provide the contract address. - CW1155 tokens. To create an **asset info** instance of this type, provide the contract address and token ID.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "native"
              ],
              "properties": {
                "native": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "cw20"
              ],
              "properties": {
                "cw20": {
                  "$ref": "#/definitions/Addr"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "cw1155"
              ],
              "properties": {
                "cw1155": {
                  "type": "array",
                  "items": [
                    {
                      "$ref": "#/definitions/Addr"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "contract_list": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractListResponse",
      "type": "object",
      "required": [
        "contracts"
      ],
      "properties": {
        "contracts": {
          "description": "Contracts (name, address)",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "$ref": "#/definitions/ContractEntry"
              },
              {
                "type": "string"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ContractEntry": {
          "description": "Key to get the Address of a contract Use [`UncheckedContractEntry`] to construct this type.",
          "type": "object",
          "required": [
            "contract",
            "protocol"
          ],
          "properties": {
            "contract": {
              "type": "string"
            },
            "protocol": {
              "type": "string"
            }
          }
        }
      }
    },
    "contracts": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractsResponse",
      "type": "object",
      "required": [
        "contracts"
      ],
      "properties": {
        "contracts": {
          "description": "Contracts (name, address)",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "$ref": "#/definitions/ContractEntry"
              },
              {
                "type": "string"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ContractEntry": {
          "description": "Key to get the Address of a contract Use [`UncheckedContractEntry`] to construct this type.",
          "type": "object",
          "required": [
            "contract",
            "protocol"
          ],
          "properties": {
            "contract": {
              "type": "string"
            },
            "protocol": {
              "type": "string"
            }
          }
        }
      }
    }
  }
}
