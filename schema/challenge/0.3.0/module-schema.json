{
  "contract_name": "module-schema",
  "contract_version": "0.3.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "Challenge instantiate message",
    "type": "object",
    "required": [
      "vote_config"
    ],
    "properties": {
      "vote_config": {
        "description": "Config for [`SimpleVoting`](abstract_std::objects::voting::SimpleVoting) object",
        "allOf": [
          {
            "$ref": "#/definitions/VoteConfig"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Threshold": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "majority"
            ],
            "properties": {
              "majority": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "percentage"
            ],
            "properties": {
              "percentage": {
                "$ref": "#/definitions/Decimal"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "VoteConfig": {
        "type": "object",
        "required": [
          "threshold"
        ],
        "properties": {
          "threshold": {
            "$ref": "#/definitions/Threshold"
          },
          "veto_duration_seconds": {
            "description": "Veto duration after the first vote None disables veto",
            "anyOf": [
              {
                "$ref": "#/definitions/Uint64"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "Challenge execute messages",
    "oneOf": [
      {
        "description": "Update challenge config",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "required": [
              "new_vote_config"
            ],
            "properties": {
              "new_vote_config": {
                "description": "New config for vote",
                "allOf": [
                  {
                    "$ref": "#/definitions/VoteConfig"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Create new challenge",
        "type": "object",
        "required": [
          "create_challenge"
        ],
        "properties": {
          "create_challenge": {
            "type": "object",
            "required": [
              "challenge_req"
            ],
            "properties": {
              "challenge_req": {
                "description": "New challenge arguments",
                "allOf": [
                  {
                    "$ref": "#/definitions/ChallengeRequest"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update existing challenge",
        "type": "object",
        "required": [
          "update_challenge"
        ],
        "properties": {
          "update_challenge": {
            "type": "object",
            "required": [
              "challenge",
              "challenge_id"
            ],
            "properties": {
              "challenge": {
                "description": "Updates to this challenge",
                "allOf": [
                  {
                    "$ref": "#/definitions/ChallengeEntryUpdate"
                  }
                ]
              },
              "challenge_id": {
                "description": "Id of the challenge to update",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Cancel challenge",
        "type": "object",
        "required": [
          "cancel_challenge"
        ],
        "properties": {
          "cancel_challenge": {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "description": "Challenge Id to cancel",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update list of friends for challenge",
        "type": "object",
        "required": [
          "update_friends_for_challenge"
        ],
        "properties": {
          "update_friends_for_challenge": {
            "type": "object",
            "required": [
              "challenge_id",
              "friends",
              "op_kind"
            ],
            "properties": {
              "challenge_id": {
                "description": "Id of the challenge to update",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "friends": {
                "description": "List of added or removed Friends",
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Friend_for_String"
                }
              },
              "op_kind": {
                "description": "Kind of operation: add or remove friends",
                "allOf": [
                  {
                    "$ref": "#/definitions/UpdateFriendsOpKind"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Cast vote as a friend",
        "type": "object",
        "required": [
          "cast_vote"
        ],
        "properties": {
          "cast_vote": {
            "type": "object",
            "required": [
              "challenge_id",
              "vote_to_punish"
            ],
            "properties": {
              "challenge_id": {
                "description": "Challenge Id to cast vote on",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "vote_to_punish": {
                "description": "Wether voter thinks admin deserves punishment",
                "allOf": [
                  {
                    "$ref": "#/definitions/Vote"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Count votes for challenge id",
        "type": "object",
        "required": [
          "count_votes"
        ],
        "properties": {
          "count_votes": {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "description": "Challenge Id for counting votes",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Veto the last vote",
        "type": "object",
        "required": [
          "veto"
        ],
        "properties": {
          "veto": {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "description": "Challenge id to do the veto",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AccountId": {
        "description": "Unique identifier for an account. On each chain this is unique.",
        "type": "object",
        "required": [
          "seq",
          "trace"
        ],
        "properties": {
          "seq": {
            "description": "Unique identifier for the accounts create on a local chain. Is reused when creating an interchain account.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0
          },
          "trace": {
            "description": "Sequence of the chain that triggered the IBC account creation `AccountTrace::Local` if the account was created locally Example: Account created on Juno which has an abstract interchain account on Osmosis, which in turn creates an interchain account on Terra -> `AccountTrace::Remote(vec![\"juno\", \"osmosis\"])`",
            "allOf": [
              {
                "$ref": "#/definitions/AccountTrace"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AccountTrace": {
        "description": "The identifier of chain that triggered the account creation",
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "local"
            ]
          },
          {
            "type": "object",
            "required": [
              "remote"
            ],
            "properties": {
              "remote": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/ChainName"
                }
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "AssetEntry": {
        "description": "An unchecked ANS asset entry. This is a string that is formatted as `src_chain>[intermediate_chain>]asset_name`",
        "type": "string"
      },
      "ChainName": {
        "description": "The name of a chain, aka the chain-id without the post-fix number. ex. `cosmoshub-4` -> `cosmoshub`, `juno-1` -> `juno`",
        "type": "string"
      },
      "ChallengeEntryUpdate": {
        "description": "Only this struct and these fields are allowed to be updated. The status cannot be externally updated, it is updated by the contract.",
        "type": "object",
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ]
          },
          "name": {
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "ChallengeRequest": {
        "description": "Arguments for new challenge",
        "type": "object",
        "required": [
          "challenge_duration_seconds",
          "init_friends",
          "name",
          "proposal_duration_seconds",
          "strike_asset",
          "strike_strategy"
        ],
        "properties": {
          "challenge_duration_seconds": {
            "description": "In what duration challenge should end",
            "allOf": [
              {
                "$ref": "#/definitions/Uint64"
              }
            ]
          },
          "description": {
            "description": "Description of the challenge",
            "type": [
              "string",
              "null"
            ]
          },
          "init_friends": {
            "description": "Initial list of friends",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Friend_for_String"
            }
          },
          "name": {
            "description": "Name of challenge",
            "type": "string"
          },
          "proposal_duration_seconds": {
            "description": "Duration set for each proposal Proposals starts after one vote initiated by any of the friends",
            "allOf": [
              {
                "$ref": "#/definitions/Uint64"
              }
            ]
          },
          "strike_asset": {
            "description": "Asset for punishment for failing a challenge",
            "allOf": [
              {
                "$ref": "#/definitions/AssetEntry"
              }
            ]
          },
          "strike_strategy": {
            "description": "How strike will get distributed between friends",
            "allOf": [
              {
                "$ref": "#/definitions/StrikeStrategy"
              }
            ]
          },
          "strikes_limit": {
            "description": "Strike limit, defaults to 1",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint8",
            "minimum": 0
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "FriendByAddr_for_String": {
        "description": "Friend by address",
        "type": "object",
        "required": [
          "address",
          "name"
        ],
        "properties": {
          "address": {
            "description": "Address of the friend",
            "type": "string"
          },
          "name": {
            "description": "Name of the friend",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Friend_for_String": {
        "description": "Friend object",
        "oneOf": [
          {
            "description": "Friend with address and a name",
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "$ref": "#/definitions/FriendByAddr_for_String"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Abstract Account Id of the friend",
            "type": "object",
            "required": [
              "abstract_account"
            ],
            "properties": {
              "abstract_account": {
                "$ref": "#/definitions/AccountId"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "StrikeStrategy": {
        "description": "Strategy for striking the admin",
        "oneOf": [
          {
            "description": "Split amount between friends",
            "type": "object",
            "required": [
              "split"
            ],
            "properties": {
              "split": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Amount for every friend",
            "type": "object",
            "required": [
              "per_friend"
            ],
            "properties": {
              "per_friend": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Threshold": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "majority"
            ],
            "properties": {
              "majority": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "percentage"
            ],
            "properties": {
              "percentage": {
                "$ref": "#/definitions/Decimal"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "UpdateFriendsOpKind": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "add"
            ],
            "properties": {
              "add": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "remove"
            ],
            "properties": {
              "remove": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Vote": {
        "description": "Vote struct",
        "type": "object",
        "required": [
          "vote"
        ],
        "properties": {
          "memo": {
            "description": "memo for the vote",
            "type": [
              "string",
              "null"
            ]
          },
          "vote": {
            "description": "true: Vote for false: Vote against",
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "VoteConfig": {
        "type": "object",
        "required": [
          "threshold"
        ],
        "properties": {
          "threshold": {
            "$ref": "#/definitions/Threshold"
          },
          "veto_duration_seconds": {
            "description": "Veto duration after the first vote None disables veto",
            "anyOf": [
              {
                "$ref": "#/definitions/Uint64"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "Challenge query messages",
    "oneOf": [
      {
        "description": "Get challenge info, will return null if there was no challenge by Id Returns [`ChallengeResponse`]",
        "type": "object",
        "required": [
          "challenge"
        ],
        "properties": {
          "challenge": {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "description": "Id of requested challenge",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get list of challenges Returns [`ChallengesResponse`]",
        "type": "object",
        "required": [
          "challenges"
        ],
        "properties": {
          "challenges": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Max amount of challenges in response",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0
              },
              "start_after": {
                "description": "start after challenge Id",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "List of friends by Id Returns [`FriendsResponse`]",
        "type": "object",
        "required": [
          "friends"
        ],
        "properties": {
          "friends": {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "description": "Id of requested challenge",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get vote of friend Returns [`VoteResponse`]",
        "type": "object",
        "required": [
          "vote"
        ],
        "properties": {
          "vote": {
            "type": "object",
            "required": [
              "challenge_id",
              "voter_addr"
            ],
            "properties": {
              "challenge_id": {
                "description": "Id of requested challenge",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "proposal_id": {
                "description": "Proposal id of previous proposal Providing None requests last proposal results",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0
              },
              "voter_addr": {
                "description": "Addr of the friend",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get votes of challenge Returns [`VotesResponse`]",
        "type": "object",
        "required": [
          "votes"
        ],
        "properties": {
          "votes": {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "description": "Id of requested challenge",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "limit": {
                "description": "Max amount of challenges in response",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0
              },
              "proposal_id": {
                "description": "Proposal id of previous proposal Providing None requests last proposal results",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0
              },
              "start_after": {
                "description": "start after Addr",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Addr"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get results of previous votes for this challenge Returns [`ProposalsResponse`]",
        "type": "object",
        "required": [
          "proposals"
        ],
        "properties": {
          "proposals": {
            "type": "object",
            "required": [
              "challenge_id"
            ],
            "properties": {
              "challenge_id": {
                "description": "Challenge Id for previous votes",
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              "limit": {
                "description": "Max amount of proposals in response",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0
              },
              "start_after": {
                "description": "start after ProposalId",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "description": "An empty struct that serves as a placeholder in different places, such as contracts that don't set a custom message.\n\nIt is designed to be expressable in correct JSON and JSON Schema but contains no meaningful data. Previously we used enums without cases, but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)",
    "type": "object"
  },
  "sudo": null,
  "responses": {
    "challenge": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChallengeResponse",
      "description": "Response for challenge query",
      "type": "object",
      "properties": {
        "challenge": {
          "description": "Challenge info, will return null if there was no challenge by Id",
          "anyOf": [
            {
              "$ref": "#/definitions/ChallengeEntryResponse"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "AdminStrikes": {
          "type": "object",
          "required": [
            "limit",
            "num_strikes"
          ],
          "properties": {
            "limit": {
              "description": "When num_strikes reached the limit, the challenge will be cancelled.",
              "type": "integer",
              "format": "uint8",
              "minimum": 0
            },
            "num_strikes": {
              "description": "The number of strikes the admin has incurred.",
              "type": "integer",
              "format": "uint8",
              "minimum": 0
            }
          },
          "additionalProperties": false
        },
        "AssetEntry": {
          "description": "An unchecked ANS asset entry. This is a string that is formatted as `src_chain>[intermediate_chain>]asset_name`",
          "type": "string"
        },
        "ChallengeEntryResponse": {
          "description": "Response struct for challenge entry",
          "type": "object",
          "required": [
            "admin_strikes",
            "challenge_id",
            "description",
            "end_timestamp",
            "name",
            "proposal_duration_seconds",
            "strike_asset",
            "strike_strategy"
          ],
          "properties": {
            "active_proposal": {
              "description": "Current active proposal",
              "anyOf": [
                {
                  "$ref": "#/definitions/ProposalInfo"
                },
                {
                  "type": "null"
                }
              ]
            },
            "admin_strikes": {
              "description": "State of strikes of admin for this challenge",
              "allOf": [
                {
                  "$ref": "#/definitions/AdminStrikes"
                }
              ]
            },
            "challenge_id": {
              "description": "Id of the challenge,",
              "type": "integer",
              "format": "uint64",
              "minimum": 0
            },
            "description": {
              "description": "Description of the challenge",
              "type": "string"
            },
            "end_timestamp": {
              "description": "When challenge ends",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "name": {
              "description": "Name of challenge",
              "type": "string"
            },
            "proposal_duration_seconds": {
              "description": "Proposal duration in seconds",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint64"
                }
              ]
            },
            "strike_asset": {
              "description": "Asset for punishment for failing a challenge",
              "allOf": [
                {
                  "$ref": "#/definitions/AssetEntry"
                }
              ]
            },
            "strike_strategy": {
              "description": "How strike will get distributed between friends",
              "allOf": [
                {
                  "$ref": "#/definitions/StrikeStrategy"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "ProposalInfo": {
          "type": "object",
          "required": [
            "config",
            "end_timestamp",
            "status",
            "total_voters",
            "votes_against",
            "votes_for"
          ],
          "properties": {
            "config": {
              "description": "Config it was created with For cases config got changed during voting",
              "allOf": [
                {
                  "$ref": "#/definitions/VoteConfig"
                }
              ]
            },
            "end_timestamp": {
              "$ref": "#/definitions/Timestamp"
            },
            "status": {
              "$ref": "#/definitions/ProposalStatus"
            },
            "total_voters": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "votes_against": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "votes_for": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            }
          },
          "additionalProperties": false
        },
        "ProposalOutcome": {
          "type": "string",
          "enum": [
            "passed",
            "failed",
            "canceled",
            "vetoed"
          ]
        },
        "ProposalStatus": {
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "active",
                "waiting_for_count"
              ]
            },
            {
              "type": "object",
              "required": [
                "veto_period"
              ],
              "properties": {
                "veto_period": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "finished"
              ],
              "properties": {
                "finished": {
                  "$ref": "#/definitions/ProposalOutcome"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "StrikeStrategy": {
          "description": "Strategy for striking the admin",
          "oneOf": [
            {
              "description": "Split amount between friends",
              "type": "object",
              "required": [
                "split"
              ],
              "properties": {
                "split": {
                  "$ref": "#/definitions/Uint128"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Amount for every friend",
              "type": "object",
              "required": [
                "per_friend"
              ],
              "properties": {
                "per_friend": {
                  "$ref": "#/definitions/Uint128"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Threshold": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "majority"
              ],
              "properties": {
                "majority": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "percentage"
              ],
              "properties": {
                "percentage": {
                  "$ref": "#/definitions/Decimal"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "VoteConfig": {
          "type": "object",
          "required": [
            "threshold"
          ],
          "properties": {
            "threshold": {
              "$ref": "#/definitions/Threshold"
            },
            "veto_duration_seconds": {
              "description": "Veto duration after the first vote None disables veto",
              "anyOf": [
                {
                  "$ref": "#/definitions/Uint64"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "challenges": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChallengesResponse",
      "description": "Response for challenges query Returns a list of challenges",
      "type": "object",
      "required": [
        "challenges"
      ],
      "properties": {
        "challenges": {
          "description": "List of indexed challenges",
          "type": "array",
          "items": {
            "$ref": "#/definitions/ChallengeEntryResponse"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "AdminStrikes": {
          "type": "object",
          "required": [
            "limit",
            "num_strikes"
          ],
          "properties": {
            "limit": {
              "description": "When num_strikes reached the limit, the challenge will be cancelled.",
              "type": "integer",
              "format": "uint8",
              "minimum": 0
            },
            "num_strikes": {
              "description": "The number of strikes the admin has incurred.",
              "type": "integer",
              "format": "uint8",
              "minimum": 0
            }
          },
          "additionalProperties": false
        },
        "AssetEntry": {
          "description": "An unchecked ANS asset entry. This is a string that is formatted as `src_chain>[intermediate_chain>]asset_name`",
          "type": "string"
        },
        "ChallengeEntryResponse": {
          "description": "Response struct for challenge entry",
          "type": "object",
          "required": [
            "admin_strikes",
            "challenge_id",
            "description",
            "end_timestamp",
            "name",
            "proposal_duration_seconds",
            "strike_asset",
            "strike_strategy"
          ],
          "properties": {
            "active_proposal": {
              "description": "Current active proposal",
              "anyOf": [
                {
                  "$ref": "#/definitions/ProposalInfo"
                },
                {
                  "type": "null"
                }
              ]
            },
            "admin_strikes": {
              "description": "State of strikes of admin for this challenge",
              "allOf": [
                {
                  "$ref": "#/definitions/AdminStrikes"
                }
              ]
            },
            "challenge_id": {
              "description": "Id of the challenge,",
              "type": "integer",
              "format": "uint64",
              "minimum": 0
            },
            "description": {
              "description": "Description of the challenge",
              "type": "string"
            },
            "end_timestamp": {
              "description": "When challenge ends",
              "allOf": [
                {
                  "$ref": "#/definitions/Timestamp"
                }
              ]
            },
            "name": {
              "description": "Name of challenge",
              "type": "string"
            },
            "proposal_duration_seconds": {
              "description": "Proposal duration in seconds",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint64"
                }
              ]
            },
            "strike_asset": {
              "description": "Asset for punishment for failing a challenge",
              "allOf": [
                {
                  "$ref": "#/definitions/AssetEntry"
                }
              ]
            },
            "strike_strategy": {
              "description": "How strike will get distributed between friends",
              "allOf": [
                {
                  "$ref": "#/definitions/StrikeStrategy"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "ProposalInfo": {
          "type": "object",
          "required": [
            "config",
            "end_timestamp",
            "status",
            "total_voters",
            "votes_against",
            "votes_for"
          ],
          "properties": {
            "config": {
              "description": "Config it was created with For cases config got changed during voting",
              "allOf": [
                {
                  "$ref": "#/definitions/VoteConfig"
                }
              ]
            },
            "end_timestamp": {
              "$ref": "#/definitions/Timestamp"
            },
            "status": {
              "$ref": "#/definitions/ProposalStatus"
            },
            "total_voters": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "votes_against": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "votes_for": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            }
          },
          "additionalProperties": false
        },
        "ProposalOutcome": {
          "type": "string",
          "enum": [
            "passed",
            "failed",
            "canceled",
            "vetoed"
          ]
        },
        "ProposalStatus": {
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "active",
                "waiting_for_count"
              ]
            },
            {
              "type": "object",
              "required": [
                "veto_period"
              ],
              "properties": {
                "veto_period": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "finished"
              ],
              "properties": {
                "finished": {
                  "$ref": "#/definitions/ProposalOutcome"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "StrikeStrategy": {
          "description": "Strategy for striking the admin",
          "oneOf": [
            {
              "description": "Split amount between friends",
              "type": "object",
              "required": [
                "split"
              ],
              "properties": {
                "split": {
                  "$ref": "#/definitions/Uint128"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Amount for every friend",
              "type": "object",
              "required": [
                "per_friend"
              ],
              "properties": {
                "per_friend": {
                  "$ref": "#/definitions/Uint128"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Threshold": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "majority"
              ],
              "properties": {
                "majority": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "percentage"
              ],
              "properties": {
                "percentage": {
                  "$ref": "#/definitions/Decimal"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "VoteConfig": {
          "type": "object",
          "required": [
            "threshold"
          ],
          "properties": {
            "threshold": {
              "$ref": "#/definitions/Threshold"
            },
            "veto_duration_seconds": {
              "description": "Veto duration after the first vote None disables veto",
              "anyOf": [
                {
                  "$ref": "#/definitions/Uint64"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "friends": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FriendsResponse",
      "description": "Response for friends query Returns a list of friends",
      "type": "object",
      "required": [
        "friends"
      ],
      "properties": {
        "friends": {
          "description": "List of friends on challenge",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Friend_for_Addr"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "AccountId": {
          "description": "Unique identifier for an account. On each chain this is unique.",
          "type": "object",
          "required": [
            "seq",
            "trace"
          ],
          "properties": {
            "seq": {
              "description": "Unique identifier for the accounts create on a local chain. Is reused when creating an interchain account.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "trace": {
              "description": "Sequence of the chain that triggered the IBC account creation `AccountTrace::Local` if the account was created locally Example: Account created on Juno which has an abstract interchain account on Osmosis, which in turn creates an interchain account on Terra -> `AccountTrace::Remote(vec![\"juno\", \"osmosis\"])`",
              "allOf": [
                {
                  "$ref": "#/definitions/AccountTrace"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "AccountTrace": {
          "description": "The identifier of chain that triggered the account creation",
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "local"
              ]
            },
            {
              "type": "object",
              "required": [
                "remote"
              ],
              "properties": {
                "remote": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/ChainName"
                  }
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "ChainName": {
          "description": "The name of a chain, aka the chain-id without the post-fix number. ex. `cosmoshub-4` -> `cosmoshub`, `juno-1` -> `juno`",
          "type": "string"
        },
        "FriendByAddr_for_Addr": {
          "description": "Friend by address",
          "type": "object",
          "required": [
            "address",
            "name"
          ],
          "properties": {
            "address": {
              "description": "Address of the friend",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "name": {
              "description": "Name of the friend",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Friend_for_Addr": {
          "description": "Friend object",
          "oneOf": [
            {
              "description": "Friend with address and a name",
              "type": "object",
              "required": [
                "addr"
              ],
              "properties": {
                "addr": {
                  "$ref": "#/definitions/FriendByAddr_for_Addr"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Abstract Account Id of the friend",
              "type": "object",
              "required": [
                "abstract_account"
              ],
              "properties": {
                "abstract_account": {
                  "$ref": "#/definitions/AccountId"
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "proposals": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ProposalsResponse",
      "description": "Response for proposals query",
      "type": "object",
      "required": [
        "proposals"
      ],
      "properties": {
        "proposals": {
          "description": "results of proposals",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint64",
                "minimum": 0
              },
              {
                "$ref": "#/definitions/ProposalInfo"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "ProposalInfo": {
          "type": "object",
          "required": [
            "config",
            "end_timestamp",
            "status",
            "total_voters",
            "votes_against",
            "votes_for"
          ],
          "properties": {
            "config": {
              "description": "Config it was created with For cases config got changed during voting",
              "allOf": [
                {
                  "$ref": "#/definitions/VoteConfig"
                }
              ]
            },
            "end_timestamp": {
              "$ref": "#/definitions/Timestamp"
            },
            "status": {
              "$ref": "#/definitions/ProposalStatus"
            },
            "total_voters": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "votes_against": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            },
            "votes_for": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0
            }
          },
          "additionalProperties": false
        },
        "ProposalOutcome": {
          "type": "string",
          "enum": [
            "passed",
            "failed",
            "canceled",
            "vetoed"
          ]
        },
        "ProposalStatus": {
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "active",
                "waiting_for_count"
              ]
            },
            {
              "type": "object",
              "required": [
                "veto_period"
              ],
              "properties": {
                "veto_period": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "finished"
              ],
              "properties": {
                "finished": {
                  "$ref": "#/definitions/ProposalOutcome"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Threshold": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "majority"
              ],
              "properties": {
                "majority": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "percentage"
              ],
              "properties": {
                "percentage": {
                  "$ref": "#/definitions/Decimal"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        },
        "VoteConfig": {
          "type": "object",
          "required": [
            "threshold"
          ],
          "properties": {
            "threshold": {
              "$ref": "#/definitions/Threshold"
            },
            "veto_duration_seconds": {
              "description": "Veto duration after the first vote None disables veto",
              "anyOf": [
                {
                  "$ref": "#/definitions/Uint64"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "vote": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VoteResponse",
      "description": "Response for vote query",
      "type": "object",
      "properties": {
        "vote": {
          "description": "The vote, will return null if there was no vote by this user",
          "anyOf": [
            {
              "$ref": "#/definitions/Vote"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Vote": {
          "description": "Vote struct",
          "type": "object",
          "required": [
            "vote"
          ],
          "properties": {
            "memo": {
              "description": "memo for the vote",
              "type": [
                "string",
                "null"
              ]
            },
            "vote": {
              "description": "true: Vote for false: Vote against",
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "votes": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VotesResponse",
      "description": "Response for previous_vote query",
      "type": "object",
      "required": [
        "votes"
      ],
      "properties": {
        "votes": {
          "description": "List of votes by addr",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "$ref": "#/definitions/Addr"
              },
              {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Vote"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Vote": {
          "description": "Vote struct",
          "type": "object",
          "required": [
            "vote"
          ],
          "properties": {
            "memo": {
              "description": "memo for the vote",
              "type": [
                "string",
                "null"
              ]
            },
            "vote": {
              "description": "true: Vote for false: Vote against",
              "type": "boolean"
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
